using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Web.Mvc;

namespace SmsFeedback_EFModels
{
   [MetadataType(typeof(SubscriptionDetail_Validation))]
   public partial class SubscriptionDetail
   {     
      #region Constants
      private const decimal cAverageSMSCost = 0.055m;
      #endregion

      #region Calculated properties
      public bool CanSendSMS
      {         
         get {
            return RemainingSMS > 0 || RemainingAmount >= cAverageSMSCost;
         }
      }
      public Decimal RemainingAmount
      {
         get
         {
            var totalToBeSpent = SpendingLimit + ExtraAddedCreditThisMonth + RemainingCreditFromPreviousMonth ;
            return totalToBeSpent - SpentThisMonth;
         }         
      } 

      public Decimal RemainingExtraCreditForNextMonth
      {
         get
         {
            var remainingCredit = Credit - SpentThisMonth;
            if (remainingCredit <= 0)
            {
               //we spent more than our credit -> so no more credit
               return 0;
            }
            else
            {
               return remainingCredit;
            }
         }
      }
      /// <summary>
      /// Get the existing Credit (previous + current)
      /// </summary>
      public Decimal Credit
      {
         get {
            return ExtraAddedCreditThisMonth + RemainingCreditFromPreviousMonth;
         }
      }

      /// <summary>
      /// Will return a non zero value only if we're over our credit
      /// </summary>
      public Decimal AmountToBeBilledFor
      {
         get 
         {
            //any extra credit you purchased will be billed
            decimal total = 0;
            //you get billed for extra sms if you went over your purchased credit + what was left from the previous month
            var remainingCredit = Credit - SpentThisMonth;
            if (remainingCredit < 0)
            {
               //this means that we spent more than our credit -> bill me
               total += Math.Abs(remainingCredit);
            }
            return total;
         }
      }
      public bool WarningsRequired()
      {
         //if we can't send any more SMS than warnings are required
         if (!CanSendSMS)
         {
            return true;
         }
         /**
          * Check if we're out of SMS
          * If no check if the current spentAmount is within warning limits of our TotalSpendingAmount
          */
         if (RemainingSMS > 0) { return false; }
         else
         {            
            if (AmountToBeBilledFor > 0 && AmountToBeBilledFor >= WarningLimit)
            {
               return true;
            }
            else
            {
               //we're not out of credit or not have reached the warning limit
               return false;
            }
         }
      }

      #endregion
      #region Helper methods
      /// <summary>
      /// Based on comparissonTime and BillingDay returns the next billing Date
      /// </summary>
      /// <returns></returns>
      public DateTime GetNextBillingDate(DateTime comparissonTime)
      {      
         /**
          * Assumption: the auto-invoice is emitted on the billing day
          * This means that we we've past the billing day with the comparissonTime's day an auto-invoice should exist
          */
         //the next billing day could be: in the future (this month or next month) or today
         var nextResetMonth = comparissonTime.Month;
         var nextResetYear = comparissonTime.Year;

         if (comparissonTime.Day > BillingDay)
         {
            nextResetMonth = comparissonTime.AddMonths(1).Month;
            nextResetYear = comparissonTime.AddMonths(1).Year;
         }
         else if (comparissonTime.Day == BillingDay)
         {
            //here I should check to see if an auto invoice was emitted for today
            //if yes than next billing day is in a month's time
            var lastAutoInvoice = this.Companies.FirstOrDefault().Invoices.Where(inv => inv.AutoGenerated).OrderByDescending(inv => inv.DateCreated).FirstOrDefault();
            if (lastAutoInvoice != null && lastAutoInvoice.DateCreated.Date == comparissonTime.Date)
            {
               //an auto invoice was sent today
               nextResetMonth = comparissonTime.AddMonths(1).Month;
               nextResetYear = comparissonTime.AddMonths(1).Year;
            }
            else
            {
               //an auto invoice will be sent - so the next billing date is today
            }
         }
         else
         {
            //today.Day < sd.BillingDate -> billing date is upcoming this month
         }
         var nextBillingDate = new DateTime(nextResetYear, nextResetMonth, BillingDay);
         return nextBillingDate;
      }
      #endregion
      #region Currencies
      public static IEnumerable<SelectListItem> DefaultCurrencies
      {
         get
         {
            SelectListItem[] currencies = new[] {
               new SelectListItem { Value = "RON", Text = "Romanian Leu" },
               new SelectListItem { Value = "EUR", Text = "Euro" },
               new SelectListItem { Value = "USD", Text = "US Dollar" }
            };
            return currencies;
         }
      }
      #endregion
   }
   #region Validation
   public class SubscriptionDetail_Validation
   {
      [DisplayName("Billing day")]
      [Required]
      [RegularExpression(@"\b([1-9]|1[0-9]|2[0-5])\b", ErrorMessage = "Invalid day: must be between 1 and 25")]
      public int BillingDay { get; set; }
      [DisplayName("SMS' included")]
      [Required]
      public int SubscriptionSMS { get; set; }
      [DisplayName("Spending Limit")]      
      [Required]
      public int SpendingLimit { get; set; }
      [DisplayName("Warning Limit")]
      [Required]
      public int WarningLimit { get; set; }
      [DisplayName("Default currency")]
      [Required]
      public string DefaultCurrency { get; set; }
   }
   #endregion


}
